<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Camera Preview Mockup (Aspect Ratios & Dynamic Tooltips)</title>
    <!-- Tailwind CSS (CDN for simple styling) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght400;600;700&display=swap" rel="stylesheet">

    <style>
        /* Custom styles for a clean, full-screen mobile experience */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #viewportContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1f2937;
        }

        #cameraFeed {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
        }

        /* --- DYNAMIC FRAME STYLES --- */
        .art-frame {
            position: absolute;
            z-index: 20;
            touch-action: none;
            box-sizing: content-box; 
            transition: border-width 0.2s, border-color 0.2s, background-color 0.2s, transform 0.2s;
            cursor: move;
        }
        
        .art-frame.active .frame-border {
            /* Highlight active frame */
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.7); 
        }

        .frame-content {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .frame-border {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks/taps to pass through to the frame content */
            transition: border-radius 0.2s;
        }

        .frame-content img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Ensure image covers the internal area */
        }
        
        .mobile-ui {
            z-index: 30;
        }

        /* Utility for centering modal */
        .modal-center {
            max-width: 90%;
        }

        /* --- ASPECT RATIO ICON STYLES --- */
        .ratio-icon {
            border: 2px solid #6366f1; /* Indigo border for visual flair */
            background-color: #374151; /* Dark background */
            flex-shrink: 0; 
            margin-left: 1rem;
            border-radius: 4px;
        }
        .ratio-icon.square { width: 32px; height: 32px; }
        .ratio-icon.rect-h-16x9 { width: 32px; height: 18px; }
        .ratio-icon.rect-h-4x3 { width: 32px; height: 24px; }
        .ratio-icon.rect-h-3x2 { width: 30px; height: 20px; }
        .ratio-icon.rect-v-9x16 { width: 18px; height: 32px; }
        .ratio-icon.rect-v-3x4 { width: 24px; height: 32px; }
        .ratio-icon.rect-v-2x3 { width: 20px; height: 30px; }
        
        /* --- TUTORIAL/TOOLTIP STYLES --- */
        .tutorial-tooltip {
            position: fixed;
            z-index: 100;
        }
        
        .tooltip-content-box {
            position: absolute; 
            pointer-events: auto; 
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            /* Custom CSS variable for arrow positioning */
            --arrow-offset: 50%;
        }

        /* Arrow pointing up (for tooltips positioned below the target) */
        .arrow-up:before {
            content: '';
            position: absolute;
            bottom: 100%; /* Position above the content box */
            border-width: 10px;
            border-style: solid;
            border-color: transparent transparent #4f46e5 transparent; /* Points up (Indigo-600) */
            z-index: 102; 
            
            /* Dynamic positioning using the custom property */
            left: var(--arrow-offset); 
            transform: translateX(-50%); 
        }
        
        /* Positioning the "Understood" button */
        .tooltip-footer {
            display: flex;
            justify-content: flex-end;
            margin-top: 1rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- Mobile Viewport Container -->
    <div id="viewportContainer">
        <!-- Live Camera Feed -->
        <video id="cameraFeed" autoplay playsinline></video>
        
        <!-- Frame container will hold all .art-frame elements -->
        <div id="frameContainer" class="w-full h-full absolute top-0 left-0 z-20">
            <!-- Frames are added here dynamically -->
        </div>

        <!-- TOP UI: Add Frame Button (Top Right) -->
        <div id="topUI" class="mobile-ui fixed top-0 right-0 p-4 z-30">
            <button id="addFrameBtn" class="bg-white text-gray-900 font-bold p-3 rounded-full shadow-2xl transform active:scale-95 transition-transform" onclick="showModal('frameSelectorModal'); dismissTutorial('tutorial_add_frame')">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                </svg>
            </button>
        </div>
        
        <!-- BOTTOM UI: Capture Button (Centered Bottom) -->
        <div id="bottomUI" class="mobile-ui fixed bottom-0 w-full p-4 flex justify-center z-30">
             <!-- Frame Capture Button -->
            <button id="captureBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-full shadow-lg hidden transform active:scale-95 transition-transform" onclick="captureFrame()">
                Capture Scene
            </button>
        </div>
        
    </div>

    <!-- Desktop Warning/Demo -->
    <div id="desktopAlert" class="hidden md:flex flex-col items-center justify-center h-screen bg-gray-900 text-white p-8">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-indigo-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 18h.01M8 21h8a2 2 0 002-2V5a2 2 0 00-2-2H8a2 2 0 00-2 2v14a2 2 0 002 2z" />
        </svg>
        <h1 class="text-3xl font-bold mb-2">Mobile Preview Tool</h1>
        <p class="text-center text-gray-400 mb-6">This tool is designed for mobile devices to access the environment camera. Please open this page on your phone or reduce your browser window width to 1024px or less.</p>
        <p class="text-sm text-gray-500">Demo mode is active for this desktop screen size.</p>
    </div>

    <!-- 1. Frame Selection Modal -->
    <div id="frameSelectorModal" class="fixed inset-0 bg-black bg-opacity-70 z-50 hidden flex items-end justify-center">
        <div class="bg-gray-800 p-6 rounded-t-2xl shadow-xl w-full max-w-md transition-all duration-300 modal-center">
            <h3 class="text-xl font-bold mb-4 border-b border-gray-700 pb-2">Add New Frame</h3>
            <div class="space-y-3">
                <h4 class="text-md font-semibold text-indigo-400 mt-2">Square / Standard</h4>
                <button class="w-full bg-gray-700 hover:bg-gray-600 p-3 rounded-lg text-left flex items-center justify-between transition-colors" onclick="addFrame('square'); hideModal('frameSelectorModal')">
                    <span class="text-white">Square (1:1)</span>
                    <div class="ratio-icon square"></div>
                </button>
                
                <h4 class="text-md font-semibold text-indigo-400 mt-4">Horizontal (Landscape)</h4>
                <button class="w-full bg-gray-700 hover:bg-gray-600 p-3 rounded-lg text-left flex items-center justify-between transition-colors" onclick="addFrame('rect-h-16x9'); hideModal('frameSelectorModal')">
                    <span class="text-white">16:9 (Widescreen)</span>
                    <div class="ratio-icon rect-h-16x9"></div>
                </button>
                <button class="w-full bg-gray-700 hover:bg-gray-600 p-3 rounded-lg text-left flex items-center justify-between transition-colors" onclick="addFrame('rect-h-4x3'); hideModal('frameSelectorModal')">
                    <span class="text-white">4:3 (Classic Photo)</span>
                    <div class="ratio-icon rect-h-4x3"></div>
                </button>
                <button class="w-full bg-gray-700 hover:bg-gray-600 p-3 rounded-lg text-left flex items-center justify-between transition-colors" onclick="addFrame('rect-h-3x2'); hideModal('frameSelectorModal')">
                    <span class="text-white">3:2 (Standard Print)</span>
                    <div class="ratio-icon rect-h-3x2"></div>
                </button>
                
                <h4 class="text-md font-semibold text-indigo-400 mt-4">Vertical (Portrait)</h4>
                <button class="w-full bg-gray-700 hover:bg-gray-600 p-3 rounded-lg text-left flex items-center justify-between transition-colors" onclick="addFrame('rect-v-9x16'); hideModal('frameSelectorModal')">
                    <span class="text-white">9:16 (Phone Story)</span>
                    <div class="ratio-icon rect-v-9x16"></div>
                </button>
                <button class="w-full bg-gray-700 hover:bg-gray-600 p-3 rounded-lg text-left flex items-center justify-between transition-colors" onclick="addFrame('rect-v-3x4'); hideModal('frameSelectorModal')">
                    <span class="text-white">3:4 (Classic Portrait)</span>
                    <div class="ratio-icon rect-v-3x4"></div>
                </button>
                <button class="w-full bg-gray-700 hover:bg-gray-600 p-3 rounded-lg text-left flex items-center justify-between transition-colors" onclick="addFrame('rect-v-2x3'); hideModal('frameSelectorModal')">
                    <span class="text-white">2:3 (Standard Print)</span>
                    <div class="ratio-icon rect-v-2x3"></div>
                </button>
            </div>
            <button class="mt-4 w-full text-indigo-400 hover:text-indigo-300 font-semibold py-2 rounded-lg" onclick="hideModal('frameSelectorModal')">
                Cancel
            </button>
        </div>
    </div>

    <!-- 2. Frame Options Modal -->
    <div id="frameOptionsModal" class="fixed inset-0 bg-black bg-opacity-70 z-50 hidden flex items-end justify-center">
        <div class="bg-gray-800 p-6 rounded-t-2xl shadow-xl w-full max-w-md transition-all duration-300 modal-center">
            <h3 class="text-xl font-bold mb-4 border-b border-gray-700 pb-2">Frame Options</h3>
            <div class="space-y-3">
                <button class="w-full bg-indigo-600 hover:bg-indigo-500 p-3 rounded-lg text-left flex items-center justify-between" onclick="showDesignModal(); hideModal('frameOptionsModal')">
                    <span>üé® Frame Design</span>
                    <span>></span>
                </button>
                <button class="w-full bg-gray-700 hover:bg-gray-600 p-3 rounded-lg text-left flex items-center justify-between" onclick="document.getElementById('imageUploader').click(); hideModal('frameOptionsModal')">
                    <span>üñºÔ∏è Upload Image</span>
                    <span>></span>
                    <input type="file" id="imageUploader" accept="image/*" class="hidden" onchange="handleImageUpload(event)">
                </button>
                <button class="w-full bg-red-600 hover:bg-red-500 p-3 rounded-lg text-left flex items-center justify-between" onclick="removeImage(); hideModal('frameOptionsModal')">
                    <span>‚ùå Remove Image</span>
                    <span>></span>
                </button>
                <button class="w-full bg-red-800 hover:bg-red-700 p-3 rounded-lg text-left flex items-center justify-between" onclick="deleteActiveFrame(); hideModal('frameOptionsModal')">
                    <span>üóëÔ∏è Delete Frame</span>
                    <span>></span>
                </button>
            </div>
            <button class="mt-4 w-full text-indigo-400 hover:text-indigo-300 font-semibold py-2 rounded-lg" onclick="hideModal('frameOptionsModal')">
                Done
            </button>
        </div>
    </div>

    <!-- 3. Frame Design Modal -->
    <div id="frameDesignModal" class="fixed inset-0 bg-black bg-opacity-70 z-50 hidden flex items-end justify-center">
        <div class="bg-gray-800 p-6 rounded-t-2xl shadow-xl w-full max-w-md transition-all duration-300 modal-center">
            <h3 class="text-xl font-bold mb-4 border-b border-gray-700 pb-2">Frame Border Design</h3>
            
            <div class="mb-4">
                <label for="borderWidthSlider" class="block mb-2 font-semibold">Border Width: <span id="currentWidth">5</span>px</label>
                <input type="range" id="borderWidthSlider" min="0" max="25" value="5" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" oninput="updateFrameDesign()">
            </div>
            
            <div class="mb-4">
                <h4 class="font-semibold mb-2">Border Color</h4>
                <div id="colorPalette" class="flex flex-wrap gap-2 mb-3">
                    <!-- Color buttons added by JS -->
                </div>
                <div class="flex items-center space-x-2">
                    <input type="color" id="colorPicker" value="#ffffff" class="w-12 h-12 rounded-lg border-2 border-gray-700 cursor-pointer" onchange="selectCustomColor()">
                    <span class="text-sm text-gray-400">or use the color picker</span>
                </div>
            </div>

            <button class="mt-4 w-full bg-indigo-600 hover:bg-indigo-500 text-white font-semibold py-3 rounded-lg transform active:scale-95 transition-transform" onclick="hideModal('frameDesignModal')">
                Apply & Close
            </button>
        </div>
    </div>

    <!-- 4. TUTORIAL 1: Add Frame -->
    <div id="tutorial_add_frame" class="tutorial-tooltip hidden">
        <div id="addFrameTooltipContent" class="tooltip-content-box arrow-up bg-indigo-600 text-white p-4 text-sm">
            <p class="font-semibold mb-2">Start here!</p>
            <p>Tap the **+** button to add your first wall art frame and choose its aspect ratio.</p>
            <div class="tooltip-footer">
                <button class="bg-indigo-700 hover:bg-indigo-800 text-white font-semibold py-1 px-3 rounded-lg transform active:scale-95 transition-transform" onclick="dismissTutorial('tutorial_add_frame')">Understood</button>
            </div>
        </div>
    </div>

    <!-- 5. TUTORIAL 2: Frame Options -->
    <div id="tutorial_frame_options" class="tutorial-tooltip hidden">
        <div id="frameOptionsTooltipContent" class="tooltip-content-box arrow-up bg-indigo-600 text-white p-4 text-sm">
            <p class="font-semibold mb-2">Customize the Frame</p>
            <p>You can **long-press (or right-click)** on any frame to upload an image, change the border, or delete it.</p>
             <div class="tooltip-footer">
                <button class="bg-indigo-700 hover:bg-indigo-800 text-white font-semibold py-1 px-3 rounded-lg transform active:scale-95 transition-transform" onclick="dismissTutorial('tutorial_frame_options')">Understood</button>
            </div>
        </div>
    </div>


    <!-- Hidden Canvas for Capture -->
    <canvas id="captureCanvas" class="hidden"></canvas>
    
<script>
    const FRAME_COLORS = ['#ffffff', '#000000', '#f87171', '#fbbf24', '#a7f3d0', '#60a5fa', '#a855f7', '#7c3aed'];
    
    // Defines the aspect ratio (Width/Height) for different types
    const ASPECT_RATIOS = {
        'square': 1.0,      // 1:1
        'rect-h-16x9': 16 / 9,
        'rect-h-4x3': 4 / 3,
        'rect-h-3x2': 3 / 2,
        'rect-v-9x16': 9 / 16,
        'rect-v-3x4': 3 / 4,
        'rect-v-2x3': 2 / 3,
    };
    
    // Base width used for visual sizing (25% of the viewport width)
    let BASE_FRAME_WIDTH_PX = 0; 

    let frames = [];
    let activeFrameId = null;
    let cameraStream = null;
    let isDeviceMobile = false;
    let longPressTimeout = null;

    // --- State and Utility Functions ---

    /** Gets a frame object by ID */
    const getFrame = (id) => frames.find(f => f.id === id);

    /** Gets the DOM element for the currently active frame */
    const getActiveFrameElement = () => activeFrameId ? document.getElementById(activeFrameId) : null;

    /** Updates the DOM element's style to reflect the state data */
    const renderFrame = (frame) => {
        const el = document.getElementById(frame.id);
        if (!el) return;

        // Apply visual scale, rotation, and translation (pan)
        el.style.transform = `translate(${frame.x}px, ${frame.y}px) rotate(${frame.rotation}deg) scale(${frame.baseScale})`;
        
        // Use BASE_FRAME_WIDTH_PX calculated from viewport size
        el.style.width = `${BASE_FRAME_WIDTH_PX}px`;
        el.style.height = `${BASE_FRAME_WIDTH_PX / frame.aspectRatio}px`;


        // Apply design
        const borderEl = el.querySelector('.frame-border');
        borderEl.style.border = `${frame.design.borderWidth}px solid ${frame.design.borderColor}`;
        
        // Adjust padding (which controls the border area in content-box model)
        el.style.padding = `${frame.design.borderWidth}px`;
        el.style.borderRadius = `${frame.design.borderRadius}px`;
        el.querySelector('.frame-content').style.backgroundColor = frame.imageSrc ? 'transparent' : '#374151'; 
        
        // Apply image
        const imgEl = el.querySelector('.frame-content img');
        if (frame.imageSrc) {
            imgEl.src = frame.imageSrc;
            imgEl.classList.remove('hidden');
        } else {
            imgEl.src = '';
            imgEl.classList.add('hidden');
        }

        // Apply active state class
        if (frame.id === activeFrameId) {
            el.classList.add('active');
        } else {
            el.classList.remove('active');
        }

        // Show/hide capture button based on frame count
        document.getElementById('captureBtn').classList.toggle('hidden', frames.length === 0);
    };

    /** Initial rendering of all frames */
    const renderAllFrames = () => {
        frames.forEach(renderFrame);
    };
    
    // --- Modal Functions ---

    const showModal = (id) => {
        document.getElementById(id).classList.remove('hidden');
    };

    const hideModal = (id) => {
        document.getElementById(id).classList.add('hidden');
    };
    
    // --- Frame Management Functions ---

    /** Adds a new frame to the viewport. */
    const addFrame = (type, initialX = 0, initialY = 0, initialScale = 1) => {
        const id = `frame-${Date.now()}`;
        const initialAspect = ASPECT_RATIOS[type] || 1.0;
        
        const newFrame = {
            id: id,
            // x and y are the offset from the center of the viewport (0, 0)
            x: initialX, 
            y: initialY, 
            baseScale: initialScale, 
            rotation: 0, 
            aspectRatio: initialAspect, 
            imageSrc: null,
            design: {
                borderWidth: 5,
                borderColor: '#ffffff',
                borderRadius: 0,
            }
        };

        frames.push(newFrame);
        createFrameDOMElement(newFrame);
        setActiveFrame(id);
        renderFrame(newFrame);
        
        // New: Check and show the second tutorial after the first frame is added
        if (frames.length === 1 && !getTutorialFlag('tutorial_frame_options_shown')) {
            // Need a slight delay for the element to be positioned correctly in the DOM
            setTimeout(() => {
                showFrameOptionsTutorial(newFrame.id);
            }, 50); 
        }
    };

    /** Creates the actual DOM structure for a frame */
    const createFrameDOMElement = (frame) => {
        const container = document.getElementById('frameContainer');
        const el = document.createElement('div');
        el.id = frame.id;
        el.className = 'art-frame';
        el.innerHTML = `
            <div class="frame-content relative w-full h-full">
                <img src="" alt="Uploaded Image" class="absolute top-0 left-0 w-full h-full object-cover hidden">
                <div class="frame-border absolute top-0 left-0 w-full h-full border-solid pointer-events-none"></div>
            </div>
        `;
        container.appendChild(el);

        // Attach event listeners for interaction
        el.addEventListener('pointerdown', handlePointerDown);
        el.addEventListener('pointerup', handlePointerUp);
        el.addEventListener('dblclick', (e) => resetFrame(frame.id));

        // Initial setup for the design modal
        setupDesignModal();
    };

    /** Sets a frame as active and updates the UI */
    const setActiveFrame = (id) => {
        // Dismiss the frame options tutorial if the user starts interacting with the frame
        dismissTutorial('tutorial_frame_options'); 
        
        const oldActiveEl = getActiveFrameElement();
        if (oldActiveEl) oldActiveEl.classList.remove('active');
        
        activeFrameId = id;

        const newActiveEl = getActiveFrameElement();
        if (newActiveEl) newActiveEl.classList.add('active');
    };
    
    /** Resets the position, scale, and rotation of a frame */
    const resetFrame = (id) => {
        const frame = getFrame(id);
        if (frame) {
            frame.x = 0;
            frame.y = 0;
            frame.baseScale = 1;
            frame.rotation = 0;
            renderFrame(frame);
        }
    };
    
    /** Deletes the active frame */
    const deleteActiveFrame = () => {
        if (!activeFrameId) return;

        const el = getActiveFrameElement();
        if (el) el.remove();

        frames = frames.filter(f => f.id !== activeFrameId);
        
        activeFrameId = null;
        
        renderAllFrames();
    };
    
    // --- Image Handling & Aspect Ratio Update ---

    const handleImageUpload = (event) => {
        if (!activeFrameId || !event.target.files.length) return;
        
        const file = event.target.files[0];
        const reader = new FileReader();
        const frame = getFrame(activeFrameId);

        reader.onload = (e) => {
            const imageUrl = e.target.result;
            
            const img = new Image();
            img.onload = () => {
                const width = img.width;
                const height = img.height;
                const aspectRatio = width / height;

                frame.imageSrc = imageUrl;
                frame.aspectRatio = aspectRatio;
                
                renderFrame(frame);
            };
            img.src = imageUrl;
        };
        
        reader.readAsDataURL(file);

        event.target.value = ''; 
    };
    
    const removeImage = () => {
        const frame = getFrame(activeFrameId);
        if (frame) {
            frame.imageSrc = null;
            frame.aspectRatio = 1; // Reset to default square aspect
            renderFrame(frame);
        }
    };


    // --- Camera and Initial Setup ---
    
    const startCamera = async () => {
        if (!isDeviceMobile) {
            return;
        }

        const video = document.getElementById('cameraFeed');
        try {
            const constraints = {
                video: {
                    facingMode: 'environment'
                }
            };
            // Request the camera stream
            cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // Success: Apply stream and start playing immediately
            video.srcObject = cameraStream;
            video.play();
            
            console.log("Camera stream started successfully.");

        } catch (err) {
            console.warn("Could not access 'environment' camera. Trying fallback.", err);
            try {
                // Fallback: Try any available video source
                const constraints = { video: true };
                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Success: Apply stream and start playing immediately
                video.srcObject = cameraStream;
                video.play();
                
            } catch (fallbackErr) {
                // Final failure: Display a background color and log error
                video.style.backgroundColor = '#374151';
                console.error("No camera found or permission denied.", fallbackErr);
            }
        }
    };

    const getDeviceType = () => {
        const width = window.innerWidth;
        // This threshold (1024px) is used to determine if we should activate the mobile/camera view
        return width <= 1024 ? 'mobile' : 'desktop';
    };

    const handleConditionalElements = () => {
        isDeviceMobile = getDeviceType() === 'mobile';
        const viewportContainer = document.getElementById('viewportContainer');
        const desktopAlert = document.getElementById('desktopAlert');
        
        // Recalculate base width on resize
        BASE_FRAME_WIDTH_PX = window.innerWidth * 0.25; 
        renderAllFrames();

        if (isDeviceMobile) {
            viewportContainer.classList.remove('hidden');
            desktopAlert.classList.add('hidden');
            // Attempt to start camera without reload
            startCamera();
        } else {
            viewportContainer.classList.add('hidden');
            desktopAlert.classList.remove('hidden');
        }
    };
    
    // --- Design Modal Logic ---
    const setupDesignModal = () => {
        const frame = getFrame(activeFrameId);
        if (!frame) return;
        
        const widthSlider = document.getElementById('borderWidthSlider');
        widthSlider.value = frame.design.borderWidth;
        document.getElementById('currentWidth').textContent = frame.design.borderWidth;
        
        document.getElementById('colorPicker').value = frame.design.borderColor;
        
        document.querySelectorAll('#colorPalette button').forEach(btn => {
            if (btn.dataset.color === frame.design.borderColor) {
                btn.classList.add('ring-4', 'ring-indigo-400');
            } else {
                btn.classList.remove('ring-4', 'ring-indigo-400');
            }
        });
    };
    
    const showDesignModal = () => {
        if (!activeFrameId) return;
        setupDesignModal();
        showModal('frameDesignModal');
    };

    const updateFrameDesign = () => {
        const frame = getFrame(activeFrameId);
        if (!frame) return;

        const width = parseInt(document.getElementById('borderWidthSlider').value, 10);
        
        frame.design.borderWidth = width;
        document.getElementById('currentWidth').textContent = width;
        
        const color = document.getElementById('colorPicker').value;
        if (FRAME_COLORS.includes(color)) {
             frame.design.borderColor = color;
        }

        renderFrame(frame);
    };

    const selectPaletteColor = (color) => {
        const frame = getFrame(activeFrameId);
        if (!frame) return;

        frame.design.borderColor = color;
        document.getElementById('colorPicker').value = color; 
        
        setupDesignModal();
        updateFrameDesign();
    };

    const selectCustomColor = () => {
        const frame = getFrame(activeFrameId);
        if (!frame) return;
        
        const color = document.getElementById('colorPicker').value;
        frame.design.borderColor = color;
        
        setupDesignModal();
        updateFrameDesign();
    };

    const createColorPalette = () => {
        const palette = document.getElementById('colorPalette');
        FRAME_COLORS.forEach(color => {
            const btn = document.createElement('button');
            btn.className = `w-8 h-8 rounded-full border-2 border-gray-600 focus:outline-none transition-all duration-150`;
            btn.style.backgroundColor = color;
            btn.dataset.color = color;
            btn.onclick = () => selectPaletteColor(color);
            palette.appendChild(btn);
        });
    };
    
    // --- Capture Logic ---
    
    const captureFrame = () => {
        const video = document.getElementById('cameraFeed');
        const canvas = document.getElementById('captureCanvas');
        
        const captureWidth = video.videoWidth || window.innerWidth;
        const captureHeight = video.videoHeight || window.innerHeight;
        
        canvas.width = captureWidth;
        canvas.height = captureHeight;
        const ctx = canvas.getContext('2d');

        if (isDeviceMobile && cameraStream) {
            ctx.drawImage(video, 0, 0, captureWidth, captureHeight);
        } else {
            // Draw placeholder background for desktop demo
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, 0, captureWidth, captureHeight);
            ctx.fillStyle = '#9ca3af';
            ctx.font = '24px Inter';
            ctx.textAlign = 'center';
            ctx.fillText('Desktop Demo Capture', captureWidth / 2, captureHeight / 2);
        }

        const frameContainer = document.getElementById('frameContainer');
        const containerRect = frameContainer.getBoundingClientRect();
        const scaleX = captureWidth / containerRect.width;
        const scaleY = captureHeight / containerRect.height;

        frames.forEach(frame => {
            const frameEl = document.getElementById(frame.id);
            if (!frameEl) return;
            
            const frameRect = frameEl.getBoundingClientRect();
            
            const domWidth = frameRect.width;
            const domHeight = frameRect.height;

            // Calculate center of frame relative to the center of the container (0,0)
            const centerX_DOM = frameRect.left + (domWidth / 2) - (containerRect.left + containerRect.width / 2);
            const centerY_DOM = frameRect.top + (domHeight / 2) - (containerRect.top + containerRect.height / 2);

            // Scale these relative coordinates for the high-res canvas
            const centerX_Canvas = (captureWidth / 2) + (centerX_DOM * scaleX);
            const centerY_Canvas = (captureHeight / 2) + (centerY_DOM * scaleY); // CORRECTED: Use DOM Y

            // Calculate final frame size on canvas
            const canvasWidth = domWidth * scaleX;
            const canvasHeight = domHeight * scaleY;
            
            ctx.save();
            ctx.translate(centerX_Canvas, centerY_Canvas);
            ctx.rotate(frame.rotation * Math.PI / 180);
            
            // Draw internal image/background
            const imgEl = frameEl.querySelector('.frame-content img');
            if (frame.imageSrc && imgEl && imgEl.naturalWidth > 0) {
                ctx.drawImage(imgEl, 
                    -canvasWidth / 2 + frame.design.borderWidth * scaleX, 
                    -canvasHeight / 2 + frame.design.borderWidth * scaleY, 
                    canvasWidth - 2 * frame.design.borderWidth * scaleX, 
                    canvasHeight - 2 * frame.design.borderWidth * scaleY
                );
            } else {
                ctx.fillStyle = '#374151';
                ctx.fillRect(
                    -canvasWidth / 2 + frame.design.borderWidth * scaleX, 
                    -canvasHeight / 2 + frame.design.borderWidth * scaleY, 
                    canvasWidth - 2 * frame.design.borderWidth * scaleX, 
                    canvasHeight - 2 * frame.design.borderWidth * scaleY
                );
            }
            
            // Draw border
            const borderWidth = frame.design.borderWidth * scaleX;
            if (borderWidth > 0) {
                ctx.strokeStyle = frame.design.borderColor;
                ctx.lineWidth = borderWidth;
                
                const innerX = -canvasWidth / 2 + borderWidth / 2;
                const innerY = -canvasHeight / 2 + borderWidth / 2;
                const innerW = canvasWidth - borderWidth;
                const innerH = canvasHeight - borderWidth;
                
                ctx.strokeRect(innerX, innerY, innerW, innerH);
            }

            ctx.restore();
        });
        
        // Open the captured image in a new tab
        canvas.toBlob(blob => {
            const url = URL.createObjectURL(blob);
            window.open(url, '_blank');
        }, 'image/png');
    };
    
    
    // --- Interaction Logic (Mobile Pinch/Pan/Rotate) ---
    
    let pointers = new Map();
    let initialMidpoint = { x: 0, y: 0 };
    let initialDistance = 0;
    let initialAngle = 0;
    let initialFrameData = null; 
    let pointerDownTime = 0;

    const handlePointerDown = (e) => {
        e.preventDefault();
        
        pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        
        const frame = getFrame(e.currentTarget.id);
        if (!frame) return;

        setActiveFrame(frame.id); // Also dismisses the second tutorial
        
        // Dismiss the tutorial if the user starts interacting with the frame
        dismissTutorial('tutorial_frame_options');

        initialFrameData = { ...frame, startX: frame.x, startY: frame.y, startScale: frame.baseScale, startRotation: frame.rotation };
        
        // Long press detection for options modal
        pointerDownTime = Date.now();
        clearTimeout(longPressTimeout);
        longPressTimeout = setTimeout(() => {
            if (pointers.has(e.pointerId) && Date.now() - pointerDownTime >= 950) { 
                showModal('frameOptionsModal');
            }
        }, 1000); 

        if (pointers.size === 2) {
            const [p1, p2] = Array.from(pointers.values());
            
            initialDistance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            initialAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x) * (180 / Math.PI);
            initialMidpoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        } else if (pointers.size > 2) {
            pointers.delete(e.pointerId);
        } else if (pointers.size === 1) {
             initialMidpoint = { x: e.clientX, y: e.clientY };
        }
    };

    const handlePointerMove = (e) => {
        if (!activeFrameId || !initialFrameData) return;
        if (!pointers.has(e.pointerId)) return;

        // Reset long press timeout on significant move
        if (pointers.size === 1) {
            const currentP = pointers.get(e.pointerId);
            const dx = Math.abs(currentP.x - initialMidpoint.x);
            const dy = Math.abs(currentP.y - initialMidpoint.y);
            if (dx > 5 || dy > 5) {
                clearTimeout(longPressTimeout);
            }
        }
        
        pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

        const frame = getFrame(activeFrameId);
        if (pointers.size === 1) {
            const currentP = pointers.get(e.pointerId);
            const movementX = currentP.x - initialMidpoint.x;
            const movementY = currentP.y - initialMidpoint.y;

            frame.x = initialFrameData.startX + movementX;
            frame.y = initialFrameData.startY + movementY;

        } else if (pointers.size === 2) {
            const [p1, p2] = Array.from(pointers.values());

            const currentDistance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const scaleFactor = currentDistance / initialDistance;
            const newScale = Math.max(0.2, Math.min(3.0, initialFrameData.startScale * scaleFactor)); // Adjusted min scale for safety
            frame.baseScale = newScale;

            const currentAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x) * (180 / Math.PI);
            const angleDelta = currentAngle - initialAngle;
            frame.rotation = initialFrameData.startRotation + angleDelta;
            
            const currentMidpoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            const deltaX = currentMidpoint.x - initialMidpoint.x;
            const deltaY = currentMidpoint.y - initialMidpoint.y;
            frame.x = initialFrameData.startX + deltaX;
            frame.y = initialFrameData.startY + deltaY;
        }

        renderFrame(frame);
    };

    const handlePointerUp = (e) => {
        e.preventDefault();
        
        clearTimeout(longPressTimeout);
        
        pointers.delete(e.pointerId);
        
        if (pointers.size < 2) {
            initialDistance = 0;
            initialAngle = 0;
            
            if (pointers.size === 1) {
                const p = Array.from(pointers.values())[0];
                initialMidpoint = { x: p.x, y: p.y };
            } else {
                initialMidpoint = { x: 0, y: 0 };
                initialFrameData = null; // Clear frame data when no pointers remain
            }
        }
    };
    
    // --- TUTORIAL LOGIC (Uses localStorage) ---
    
    /** Checks if a tutorial flag is set in localStorage (returns true if set/shown) */
    const getTutorialFlag = (flagName) => {
        return localStorage.getItem(flagName) === 'shown';
    };

    /** Sets a tutorial flag in localStorage and dismisses the tooltip */
    const dismissTutorial = (id) => {
        const tooltipEl = document.getElementById(id);
        if(tooltipEl) tooltipEl.classList.add('hidden');
        localStorage.setItem(id + '_shown', 'shown');
    };

    /** Shows the 'Add Frame' tutorial (first step) */
    const showAddFrameTutorial = () => {
        if (getTutorialFlag('tutorial_add_frame_shown')) return;
        
        const tooltipEl = document.getElementById('tutorial_add_frame');
        const btnEl = document.getElementById('addFrameBtn');
        const tooltipContent = document.getElementById('addFrameTooltipContent');

        if (!tooltipEl || !btnEl || !tooltipContent) return;

        const btnRect = btnEl.getBoundingClientRect();
        const tooltipWidth = 280; // Fixed width for easier calculation for responsiveness

        // 1. Position the main tooltip container 
        const tooltipTop = btnRect.bottom + 10;
        // Try to center the tooltip horizontally below the button
        let tooltipLeft = btnRect.left + (btnRect.width / 2) - (tooltipWidth / 2);

        // Boundary check: ensure the tooltip doesn't go off the screen left
        if (tooltipLeft < 10) {
            tooltipLeft = 10;
        }

        // Boundary check: ensure the tooltip doesn't go off the screen right
        if (tooltipLeft + tooltipWidth > window.innerWidth - 10) {
            tooltipLeft = window.innerWidth - tooltipWidth - 10;
        }

        // 2. Calculate the Arrow Offset
        // Target Center = btnRect.left + btnRect.width / 2
        // Arrow Offset from Tooltip Left = Target Center - tooltipLeft
        let arrowOffset = (btnRect.left + (btnRect.width / 2)) - tooltipLeft;

        // Ensure the arrow offset stays within the content box boundaries
        // Arrow width is 20px (10px border * 2), so stay away from edges by at least 15px
        arrowOffset = Math.max(15, Math.min(tooltipWidth - 15, arrowOffset));

        // Apply positioning and arrow offset
        tooltipContent.style.width = `${tooltipWidth}px`;
        tooltipContent.style.top = `${tooltipTop}px`;
        tooltipContent.style.left = `${tooltipLeft}px`;
        tooltipContent.style.setProperty('--arrow-offset', `${arrowOffset}px`); // Set the CSS variable

        tooltipEl.classList.remove('hidden');
    };

    /** Shows the 'Frame Options' tutorial (second step) */
    const showFrameOptionsTutorial = (frameId) => {
        if (getTutorialFlag('tutorial_frame_options_shown')) return;
        
        const frameEl = document.getElementById(frameId);
        const tooltipEl = document.getElementById('tutorial_frame_options');
        const tooltipContent = document.getElementById('frameOptionsTooltipContent');

        if (!frameEl || !tooltipEl || !tooltipContent) return;
        
        const frameRect = frameEl.getBoundingClientRect();
        const tooltipWidth = 280; 

        // 1. Position the main tooltip container 
        const tooltipTop = frameRect.top + frameRect.height + 25; // Position below the frame

        // Try to center horizontally below the frame
        let tooltipLeft = frameRect.left + (frameRect.width / 2) - (tooltipWidth / 2);
        
        // Boundary checks (keep it inside the viewport)
        if (tooltipLeft < 10) tooltipLeft = 10;
        if (tooltipLeft + tooltipWidth > window.innerWidth - 10) {
             tooltipLeft = window.innerWidth - tooltipWidth - 10;
        }
        
        // 2. Calculate the Arrow Offset
        let arrowOffset = (frameRect.left + (frameRect.width / 2)) - tooltipLeft;
        arrowOffset = Math.max(15, Math.min(tooltipWidth - 15, arrowOffset));


        // Apply positioning
        tooltipContent.style.width = `${tooltipWidth}px`;
        tooltipContent.style.top = `${tooltipTop}px`; 
        tooltipContent.style.left = `${tooltipLeft}px`;
        tooltipContent.style.setProperty('--arrow-offset', `${arrowOffset}px`); // Set the CSS variable

        // Attach dismissal logic to the frame itself to dismiss on interaction
        frameEl.addEventListener('pointerdown', () => dismissTutorial('tutorial_frame_options'), { once: true });
        
        tooltipEl.classList.remove('hidden');
    };

    // --- Initialization ---

    document.addEventListener('DOMContentLoaded', () => {
        createColorPalette();
        
        // Initialize BASE_FRAME_WIDTH_PX before initial frame creation
        BASE_FRAME_WIDTH_PX = window.innerWidth * 0.25; 

        handleConditionalElements();
        window.addEventListener('resize', () => {
             handleConditionalElements();
             // Recalculate and reposition tooltips on resize if they are visible
             if (!document.getElementById('tutorial_add_frame').classList.contains('hidden')) {
                 showAddFrameTutorial();
             }
             if (!document.getElementById('tutorial_frame_options').classList.contains('hidden') && activeFrameId) {
                 showFrameOptionsTutorial(activeFrameId);
             }
        });
        
        const viewport = document.getElementById('viewportContainer');
        viewport.addEventListener('pointermove', handlePointerMove);
        viewport.addEventListener('pointerup', handlePointerUp);
        viewport.addEventListener('pointercancel', handlePointerUp);
        
        // Show the first tutorial immediately if it hasn't been shown
        showAddFrameTutorial();
    });

</script>
</body>
</html>
